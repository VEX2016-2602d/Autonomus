#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(Sensor, in1,    pincherDegreeR, sensorPotentiometer)
#pragma config(Sensor, in2,    pincherDegreeL, sensorPotentiometer)
#pragma config(Sensor, in3,    battery2,       sensorAnalog)
#pragma config(Sensor, dgtl7,  encoderArm,     sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  encoderL,       sensorQuadEncoder)
#pragma config(Sensor, dgtl11, encoderR,       sensorQuadEncoder)
#pragma config(Motor,  port2,           pincherR,      tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port3,           pincherL,      tmotorVex393_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port4,           armR1,         tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port5,           armR2,         tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port6,           armL1,         tmotorVex393_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port7,           armL2,         tmotorVex393_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port8,           chassisR,      tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port9,           chassisL,      tmotorVex393_MC29, openLoop, driveLeft)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*														MARGINAL VALUES 															 */
/*---------------------------------------------------------------------------*/

char autonomousCount;
bool startingLeft;

const char leftButton = 1;
const char centerButton = 2;
const char rightButton = 4;

///For 15 sec autonomous, 8 rubbers
const int armFullCube =90;
const int armFull = 90;
const int armHoldNone = 30;
const int armHoldStar = 42;
const int armHoldCube = 47;
const int armHold3Star = 60;
const int armHoldCubeandStar = 70;

const int turn45 = 130;
const int turn90 = 280;
const int turn180 = 320;

const int pincherLOpen = 1050;
const int pincherROpen = 1050;
const int pincherLMid = 1550;
const int pincherRMid = 1500;
const int pincherLRelease = 1700;
const int pincherRRelease = 1700;
const int pincherLClose = 1950;
const int pincherRClose = 1800;

int gyroAngle;
/*---------------------------------------------------------------------------*/

/* 												BASIC MOVEMENTS                  									 */
/*---------------------------------------------------------------------------*/
void armDrive(int armspeed)
{
	motor[armL1] = armspeed;
	motor[armR1] = armspeed;
	motor[armL2] = armspeed;
	motor[armR2] = armspeed;
}

void chassisDrive(int chassisR, int chassisL)
{
	motor[chassisR] = chassisR;
	motor[chassisL] = chassisL;
}

void pincherDrive(int pincherspeed)
{
	motor[pincherL] = pincherspeed;
	motor[pincherR] = pincherspeed;
}
/*---------------------------------------------------------------------------*/

/* 												RESET FUNCTIOINS																	 */
/*---------------------------------------------------------------------------*/
void resetChassisEncoders()
{
	SensorValue[encoderR]=0;
	SensorValue[encoderL]=0;
}

void resetArmEncoder()
{
	SensorValue[encoderArm]=0;
}

int pCalc(int target, tSensors sensorName,float pValue)//change the return value later if this work
{
	int error = abs(target - SensorValue[sensorName]);
	int index = (int)error * pValue;
	if(index > 125)//prevent overshot the motor
	{
		index = 125;
	}
	else
	{
		index = index;
	}

	return index;
}

void gyroSetup()
{
  SensorType[in8] = sensorNone;
  wait1Msec(1000);
  SensorType[in8] = sensorGyro;
  wait1Msec(2000);
  SensorScale[in8] = 140;//#1 Gyro
  /*SensorType[in5] = sensorNone;
  wait1Msec(1000);
  SensorType[in5] = sensorGyro;
  wait1Msec(2000);
  SensorScale[in5] = 131;*/
}

task gyroFilter()
{
  int     gyro_Read;
  int     gyro_Error = 0;
  int     lastDriftGyro = gyroAngle;

  int     angle;
  long    nSysTimeOffset;

  nSysTimeOffset = nSysTime;

  while(true)
  {
  	gyro_Read=SensorValue[in8];
    //if the angle speed smaller than 20/s than consider as a drift
    if( (nSysTime - nSysTimeOffset) > 250 )
      {
        if( abs( gyro_Read - lastDriftGyro ) < 3
        	)
        {
          gyro_Error += (lastDriftGyro - gyro_Read);
        }
        lastDriftGyro = gyro_Read;
        nSysTimeOffset = nSysTime;
      }
      angle = (gyro_Read + gyro_Error)/10;

      //fit the runover
      if(angle< -360)
      {
        angle += 360;
      }
      else if(angle >360)
      {
        angle -= 360;
      }
      else
      {
        angle = angle;
  		}
      gyroAngle = angle; //store the result to global variable;
      wait1Msec(15);
  }
}

/*task ledBattery()
{
	float mainBattery = nImmediateBatteryLevel/1000.0;
	float backup = SensorValue[battery2]/280.0;
	while(true)
	{
		if(mainBattery>8.2)
		{
			SensorValue[mainBatteryLED]=1;
		}
		else if(7.9<mainBattery<8.2)
		{
			for(int i=0; i<10; i++)
			{
			SensorValue[dgtl11] =1;
			wait1Msec(500);
			SensorValue[dgtl11] =0;
			wait1Msec(500);
			}
		}
		else
		{
			SensorValue[mainBatteryLED]=0;
		}

		if(backup>8.2)
		{
			SensorValue[backupBatteryLED]=1;
		}
		else if(7.9<backup<8.2)
		{
			for(int i=0; i<10; i++)
			{
			SensorValue[backupBatteryLED] =1;
			wait1Msec(500);
			SensorValue[backupBatteryLED] =0;
			wait1Msec(500);
			}
		}
		else
		{
			SensorValue[backupBatteryLED]=0;
		}

	}
}*/
void waitForPress()
{
	while(nLCDButtons == 0)
  {
  }
  wait1Msec(500);
}
/*---------------------------------------------------------------------------*/

/* 													AUTONOMOUS BASIC																 */
/*---------------------------------------------------------------------------*/
void chassisTurn(int turnTarget,bool ifClockwise)
{
	resetChassisEncoders();
	int encoderTarget;
	int turnIndex;
	int turnError;
	switch(turnTarget)
	{
	case 45:
		encoderTarget = turn45;
		break;
	case 90:
		encoderTarget = turn90;
		break;
	case 180:
		encoderTarget = turn180;
		break;
	}
	while(((abs(SensorValue[encoderL]) + abs(SensorValue[encoderR]))/2)<encoderTarget)
	{
		turnError = encoderTarget - ((abs(SensorValue[encoderL]) + abs(SensorValue[encoderR]))/2);
		turnIndex = (int)turnError*0.4;
		if(turnIndex > 120)//prevent overshot the motor
		{
			turnIndex = 120;
		}
		else
		{
			turnIndex = turnIndex;
		}

		if(turnError<25)//if the error is small enough, then stop this function
		{
			break;
		}
    if(ifClockwise)
    {
		  motor[chassisR] = -turnIndex;
			motor[chassisL] = turnIndex;
    }
    else
    {
      motor[chassisR] = turnIndex;
			motor[chassisL] = -turnIndex;
    }

	}
	chassisDrive(0,0);
}

void gyroTurn(int nDegree,int timeLimit)
{
	int error;
  float index;
	int preError = gyroAngle - nDegree;
	int derivative;
  clearTimer(T2);
  while(time1[T2]<timeLimit)
  {
    error = gyroAngle - nDegree;
    derivative = error-preError;
    preError = error;
    index = 2*error+5.8*derivative;

  	if(index > 120)//prevent overshot the motor
		{
		index = 120;
		}
		else if(index<-120)
		{
			index = -120;
		}
		else
		{
		index = index;
		}
    motor[chassisL] = index;
    motor[chassisR] = -index;
    wait1Msec(25);
  }
  motor[chassisL] = 0;
  motor[chassisR] = 0;
}

void gyroAdjustment(int nDegree)//counterclockwise is postive
{
  int error;
  float index;
  int intergrate=0;
  clearTimer(T1);
  while(time1[T1]<500)
  {
    error = abs(gyroAngle - nDegree);
    intergrate +=error;
    index = 16*error + 0.1*intergrate;
    if(index>30)
    	index = 30;
   	else
   		index = index;
   if(gyroAngle>nDegree)
   {
    motor[chassisL] = index;
    motor[chassisR] = -index;
 		}
 		else if(gyroAngle<nDegree)
 		{
 		motor[chassisL] = -index;
    motor[chassisR] = index;
 		}
 		else
 		{
 		motor[chassisL] = 0;
    motor[chassisR] = 0;
  	}
    wait1Msec(25);
  }
  motor[chassisL] = 0;
  motor[chassisR] = 0;
}

void pidStraight(bool forward,bool ifLift,bool ifHoldPincher,int target)
{
	float kPL;
	float kPR;
	float kIL;
	float kIR;
	float kDL;
	float kDR;
	float indexR=0.0;
	float indexL=0.0;
	int integralLimit;
	if(target>=1200)
	{
		kPL = 0.3*1.3;
		kPR = 0.3;
		kIL = 0.00005;
		kIR = 0.00005;
		kDL = 1.5;
		kDR = 1.5;
		integralLimit = 80;
	}

	else if(500<= target <1200)
	{
		kPL = 0.5*1.2;
		kPR = 0.5;
		kIL = 0.00005;
		kIR = 0.00004;
		kDL = 3;//was 1
		kDR = 3;//was 1
		integralLimit = 50;
	}
	else
	{
		kPL = 0.4*1.2;
		kPR = 0.4;
		kIL = 0.00006;
		kIR = 0.00006;
		kDL = 1;
		kDR = 1;
		integralLimit = 50;
	}

	int errorL;
	int preErrorL = target;
	int integralL =0;
	int derivativeL;
	int errorR;
	int preErrorR = target;
	int integralR =0;
	int derivativeR;

	char lowSpeedCountL=0;
	char lowSpeedCountR=0;

	resetChassisEncoders();

	while(((abs(SensorValue[encoderR])) < target) || ((abs(SensorValue[encoderL]))< target))
	{
		errorL = target - abs(SensorValue[encoderL]);
		errorR = target - abs(SensorValue[encoderR]);

		integralL += errorL;
		integralR += errorR;

		if(abs(errorL) < integralLimit)
		{
			integralL = 0;
		}

		if(abs(errorR) < integralLimit)
		{
			integralR = 0;
		}

		derivativeL = errorL - preErrorL;
		derivativeR = errorR - preErrorR;

		preErrorL = errorL;
		preErrorR = errorR;


		indexL = kPL*errorL + kIL*integralL + kDL*derivativeL;
		indexR = kPR*errorR + kIR*integralR + kDR*derivativeR;

		if(errorR < 150 && abs(derivativeR)< 2)
		{
			lowSpeedCountR++;
		}

		if(errorL < 150 && abs(derivativeL)< 2)
		{
			lowSpeedCountL++;
		}

		if(lowSpeedCountL>5 || lowSpeedCountR>5)
			break;

		if(indexR > 125)//prevent overshot the motor
		{
			indexR = 125;
		}
		else
		{
			indexR = indexR;
		}

		if(indexL > 125)
		{
			indexL = 125;
		}
		else
		{
			indexL = indexL;
		}

		if(forward)
		{
				motor[chassisR]=indexR;
				motor[chassisL]=indexL;
		}
		else
		{
				motor[chassisR]=-indexR;
				motor[chassisL]=-indexL;
		}

		if(ifLift && errorR <180)
		{
			armDrive(125);
		}

		if(ifHoldPincher && errorR>100)
		{
			pincherDrive(20);
		}
		wait1Msec(25);
	}
	motor[chassisR]=0;
	motor[chassisL]=0;
}

void autoOpenPincher()
{
	while(SensorValue[pincherDegreeL] > pincherLOpen  || SensorValue[pincherDegreeR] > pincherROpen)
	{
		int openIndexL = pCalc(pincherLOpen, pincherDegreeL, 0.9);
		int openIndexR = pCalc(pincherROpen, pincherDegreeR,0.9);

		if(openIndexL < 20 || openIndexR <20)
		{
			break;
		}

		if(SensorValue[pincherDegreeL] > pincherLOpen)
		{
			motor[pincherL] = -openIndexL;
		}

		if(SensorValue[pincherDegreeR] > pincherROpen)
		{
			motor[pincherR] = -openIndexR;
		}
	}
	pincherDrive(0);
}

void autoClosePincher()
{
	int preReadL = 1000;
	int preReadR = 1000;
	int speedL;
	int speedR;
	int currentReadL;
	int currentReadR;
	char achievedCountL =0;
	char achievedCountR =0;
	pincherDrive(125);
	wait1Msec(200);
	clearTimer(T4);
	while(time1[T4]<650 &&(SensorValue[pincherDegreeL] < pincherLClose || SensorValue[pincherDegreeR] < pincherRClose))
	{
		currentReadL = SensorValue[pincherDegreeL];
		currentReadR = SensorValue[pincherDegreeR];

		speedL = abs(currentReadL - preReadL);
		speedR = abs(currentReadR - preReadR);

		if(SensorValue[pincherDegreeL] < pincherLClose)
		{
			if(speedL>5)
			{
				motor[pincherL] =125;
			}
			else
			{
				achievedCountL++;
				motor[pincherL] = 0;
			}
		}
		else
		{
			motor[pincherL] = 0;
		}

		if(SensorValue[pincherDegreeR] < pincherRClose)
		{
			if(speedR>5)
			{
				motor[pincherR] =125;
			}
			else
			{
				achievedCountR++;
				motor[pincherR] = 0;
			}
		}
		else
		{
			motor[pincherR] = 0;
		}

		if(achievedCountL >2 && achievedCountR >2)
		{
			break;
		}
		preReadL = currentReadL;
		preReadR = currentReadR;
		wait1Msec(25);
	}
	pincherDrive(0);
}

void midPincher()
{
	int indexR;
	int indexL;
	clearTimer(T2);
	while((time1(T2)<700) && (((pincherLMid-5)<SensorValue[pincherDegreeL] <(pincherLMid+5))  || ((pincherRMid-5)<SensorValue[pincherDegreeR] <(pincherRMid+5))))
	{
    if(SensorValue[pincherDegreeR]<(pincherRMid-5))
    {
    	indexR = pCalc(pincherRMid, pincherDegreeR,0.1);
      motor[pincherR] = indexR;
    }
    else if(SensorValue[pincherDegreeR] > (pincherRMid+5))
    {
    	indexR = pCalc(pincherRMid, pincherDegreeR,0.1);
      motor[pincherR] = - indexR;
    }
   	else
   		motor[pincherR] =0;

    if(SensorValue[pincherDegreeL]< (pincherLMid-5))
    {
    	indexL = pCalc(pincherLMid, pincherDegreeL, 0.1);
      motor[pincherL] = indexL;
    }
    else if(SensorValue[pincherDegreeL] > (pincherLMid+5))
    {
    	indexL = pCalc(pincherLMid, pincherDegreeL, 0.1);
      motor[pincherL] = - indexL;
    }
    else
    	motor[pincherL] = 0;
	}
  pincherDrive(0);
}

void releasePincher()//6 each side
{
	clearTimer(T3);
	while(time1[T3]<150)
	{
  pincherDrive(-125);
	}
	pincherDrive(0);
}

void autoArmDown()
{
	while(abs(SensorValue[encoderArm])>20)
	{
		armDrive(-80);
	}
	armDrive(0);
}

void autoArmDownSpec()
{
	while(abs(SensorValue[encoderArm])>3)
	{
		armDrive(-100);
	}
	armDrive(0);
}

void autoArmUp(char type)
{
	int mv_armUp;
	switch(type)
	{
	case 1:
		 mv_armUp= armFull;
		break;
	case 2:
		mv_armUp = armFullCube;
		break;
	}
	while(abs(SensorValue[encoderArm])<mv_armUp)
	{
		armDrive(125);
	}
	armDrive(0);
}

void autoArmHold(char type)
{
	int mv_armHold;

	switch(type)
	{
		case 0:
		mv_armHold = armHoldNone;
		break;
		case 1:
	 	mv_armHold= armHoldStar;
		break;
		case 2:
		mv_armHold = armHoldCube;
		break;
		case 3:
		mv_armHold = armHold3Star;
		break;
		case 4:
		mv_armHold = armHoldCubeandStar;
	}

	while(abs(SensorValue[encoderArm])<mv_armHold)
	{
		armDrive(60);
		pincherDrive(15);
		wait1Msec(25);
	}
	armDrive(0);
}

void midArm()
{
	while(abs(SensorValue[encoderArm])> 65)
	{
		armDrive(-70);
		wait1Msec(25);
	}
	armDrive(0);
}

void flashLED(int n)
{
	for(int i=0; i<n; i++)
			{
			bLCDBacklight=true;
			wait1Msec(500);
			bLCDBacklight=false;
			wait1Msec(500);
			}
}

/*---------------------------------------------------------------------------*/

/*											AUTONOMOUS MOVEMENTS																	*/
/*---------------------------------------------------------------------------*/
void autonomousA1()
{
	if(startingLeft)
	{
		releasePincher();
		wait1Msec(300);
		pidStraight(false,false,false,200);
		pidStraight(true,false,false,1300); // Drive straight to the far star cluster//900
		wait1Msec(100);
		autoClosePincher(); // Close pincher aroudn the star cluste
		pidStraight(false,false,true,1100); // Drive back to starting posistion
		autoArmHold(3);
    gyroTurn(-90,900);
    pidStraight(false,false,true,500);
    autoArmDown();
		pidStraight(false,true,true,850); // Move backwards to the fence
		autoArmUp(1);
		autoOpenPincher();
		autoArmDown();
	}
	else
	{
	}
}

void autonomousA2()
{
	if(startingLeft)
	{
		releasePincher();
		wait1Msec(250);
		pidStraight(false,false,false,200);
		pidStraight(true,false,false,825); // Drive straight to the far star cluster
		autoClosePincher(); // Close pincher aroudn the star cluste
		wait1Msec(50);
		pidStraight(false,false,true,675); // Drive back to starting posistion
		autoArmHold(2);
	  gyroTurn(-90,700);
		pidStraight(false,false,true,1350); // Move backwards to the fence
		autoArmUp(1);
		autoOpenPincher();
		autoArmDown();
		gyroTurn(-25,700);
		autoOpenPincher();
		pidStraight(true,false,false,700);
		autoClosePincher();
		pidStraight(false,true,true,675);
		autoArmUp(2);
		autoOpenPincher();
	}
	else
	{
	}
}


void autonomousB1()
{
	if(startingLeft)
	{
	releasePincher();
	wait1Msec(200);
	autoOpenPincher();
	pidStraight(true,false,false,650);
	autoClosePincher();
	autoClosePincher();
	autoArmHold(2);
	gyroTurn(-110,1000);
	autoClosePincher();
	pidStraight(false,true,true,700);
	autoArmUp(2);
	autoOpenPincher();
	autoArmDown();
	}
	else
	{
	}
}

void autonomousB2()
{
		if(startingLeft)
	{
	releasePincher();
	wait1Msec(200);
	autoOpenPincher();
	autoOpenPincher();
	pidStraight(true,false,false,900);//increase to push the cube
	autoClosePincher();
	autoClosePincher();
	autoArmHold(2);
	gyroTurn(-130,1000);
	autoClosePincher();
	pidStraight(false,true,true,800);
	autoArmUp(2);
	autoOpenPincher();
	autoArmDown();
	pidStraight(true,false,false,850);
	autoClosePincher();
	pidStraight(false,true,true,850);
	autoArmUp(1);
	autoOpenPincher();
	}
	else
	{
	}
}

void autonomousC()
{
	autoOpenPincher();
	wait1Msec(200);
	autoArmHold(0);
	pidStraight(true,false,false,1100);
}

void autonomousSkills()
{
	//SetUp
		/*resetArmEncoder();
		resetChassisEncoders();
		gyroSetup();
		startTask(gyroFilter);*/

		releasePincher();
		pidStraight(false,false,false,200);
		pidStraight(true,false,false,1200); // Drive straight to the far star cluster
		wait1Msec(100);
		autoClosePincher(); // Close pincher aroudn the star cluste
		autoClosePincher();
		pidStraight(false,false,true,1100); // Drive back to starting posistion
		autoArmHold(3);
    gyroTurn(-90,800);//800 ms turn, subject to change
    pidStraight(false,false,true,500);
    autoArmDown();
		pidStraight(false,true,true,850); // Move backwards to the fence
		autoArmUp(1);
		autoOpenPincher();
		wait1Msec(50);
		autoArmDown();
		gyroAdjustment(-90);
		// End of Actions 1 - 6 : Getting the far star cluster

		// Start of Actions 17 - 28 : Preloads
		autoOpenPincher(); // D-fix
		pidStraight(true,false,false,725); // Move to starting area
		wait1Msec(100);
		autoClosePincher(); // Secure the VEX Cube preload
		pidStraight(false,true,true,725); // Move back towards the fence
		autoArmUp(2); // Raise the arm
		autoOpenPincher(); // Drop the VEX Cube
		wait1Msec(50); // Wait to ensure the cube has dropped
		autoArmDown(); // Lower arm down to the ground
		gyroAdjustment(-90);

		autoOpenPincher(); // D-fix
		pidStraight(true,false,false,725); // Move to starting area
		wait1Msec(100);
		autoClosePincher(); // Secure the VEX Cube preload
		pidStraight(false,true,true,725); // Move back towards the fence
		autoArmUp(2); // Raise the arm
		autoOpenPincher(); // Drop the VEX Cube
		wait1Msec(50); // Wait to ensure the cube has dropped
		autoArmDown(); // Lower arm down to the ground
		gyroAdjustment(-90);

		autoOpenPincher(); // D-fix
		pidStraight(true,false,false,650); // Move to starting area
		wait1Msec(200); // Wait for preload to be placed
		autoClosePincher(); // Secure the VEX Cube preload
		pidStraight(false,true,true,600); // Move back towards the fence
		autoArmUp(1); // Raise the arm
		autoOpenPincher(); // Drop the VEX Cube
		wait1Msec(100); // Wait to ensure the cube has dropped
		midArm(); //lower the arm to the mid, prepare for next run
		autoClosePincher();
		pidStraight(true,false,false,90);
		gyroTurn(0,1000);

		wait1Msec(100);
		pidStraight(false,false,false,250);
		midPincher();
		autoArmDownSpec();
		pidStraight(true,false,false,2000);
		autoClosePincher();
		autoArmHold(3);
		gyroTurn(-90,800);
		waitForPress();
		pidStraight(false,false,true,100);
		autoArmUp(1);
		autoOpenPincher();
		wait1Msec(50);
		midArm();
		pidStraight(true,false,false,70);

		waitForPress();
		gyroTurn(3,1000);//0 in gloabl
		pidStraight(true,false,false,700);//650 in gloabl
		gyroTurn(-90,800);
		autoArmDownSpec();
		autoOpenPincher();
		pidStraight(true,false,false,550);
		autoClosePincher();
		pidStraight(false,true,true,1050);
		autoArmUp(2);
		autoOpenPincher();

		autoArmDown();
		pidStraight(true,false,false,500);
		gyroTurn(-180,1000);
		autoArmDown();
		autoOpenPincher();
		pidStraight(true,false,false,450);
		autoClosePincher();
		autoArmHold(2);
		pidStraight(true,false,true,1000);// make sure travel enough distance so the cube will pust stars on ZONE B
		gyroTurn(-90,3);
		pidStraight(false,true,true,650);
		autoArmUp(2);
		autoOpenPincher();
}

/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/




task main()
{
	/*releasePincher();
	bLCDBacklight=true;
	displayLCDNumber(0,1,time1[T3]);
	wait1Msec(1000);*/
	pidStraight(true,false,false,900);
	/*autoArmUp(1);
	wait1Msec(1000);
	midArm();
	wait1Msec(5000);
	autoArmDown();*/
	//resetArmEncoder();
	//gyroSetup();
	//flashLED(3);
	//startTask(gyroFilter);
	//wait1Msec(50000);
	//chassisTurn(90,true);
	//gyroAdjustment(0);
	//midArm();
	//startingLeft=true;
	//chassisTurn(90,true);
	//chassisTurn(90,false);
	//autonomousForward();
	//autonomousCubeandStar();
	//motor[chassisR] = 100;
	//motor[chassisL] = 100;
  //wait1Msec(1000000);
 	//motor[chassisR] = 0;
	//motor[chassisL] = 0;
	/*gyroAdjustment(-690);
	bLCDBacklight=true;
	clearLCDLine(0);
	clearLCDLine(1);
	displayLCDNumber(0,5,SensorValue[in4]);
	displayLCDNumber(1,5,time1(T3));*/
	//wait1Msec(200000);
	//flashLED(5);
	//midPincher();
	//autoClosePincher();
	//flashLED(5);
	//autoOpenPincher();
	///////////////////////////////////////
	//pidStraight(true,false,300);
	//gyroTurn(55,3);
	//pidStraight(true,false,700);
	//autoClosePincher();
	//autoArmHold();
	//pidStraight(true,false,
	/////////////////////////////////

	/////////////////////////////////

	//////////////////////////////
	/*clearLCDLine(1);
	bLCDBacklight = true;
	displayLCDNumber(1,5,gyroAngle);
	wait1Msec(1500);*/
	//pidStraight(true,false,800);
	//autoOpenPincher();
	//pidStraight(true,300);
	//autoClosePincher();
	//midPincher();
	//wait1Msec(5000);
	//autoOpenPincher();
	//gyroTurn(-685);
	//wait1Msec(2000000);
	//gyroAdjustment(0);
	//autoClosePincher();
	//wait1Msec(1000);
	//autoArmUp(1);
	//autoOpenPincher();
	//autoArmDown();
	//flashLED(5);
	//autoArmUp(2);
	//autoOpenPincher();
	//midPincher();
	//pincherDrive(10);
	/*resetChassisEncoders();
	motor[chassisR]=100;
	motor[chassisL]=100;
	wait1Msec(20000);
	chassisDrive(0,0);*/
	//pidStraight(false,true,800);
	//autoarmUp(2);
	//autoOpenPincher();
	//gyroTurn(-90,3);
	//pidStraight(true,false,900);
	//autoClosePincher();
	//autoArmHold(1);
	//autoarmHold(2);
	/*for(int i=0; i<5;i++)
	{
	autoArmUp(2);
	autoOpenPincher();
	autoArmDown();
	gyroAdjustment(0);
	bLCDBacklight = true;
	displayLCDNumber(1,5,gyroAngle);
	wait1Msec(500);
	}*/
	//gyroAdjustment(0);
	//flashLED(5);
	//pidStraight(true,false,1000);

	/*motor[chassisR] = 22;
	motor[chassisL] = -22;
	wait1Msec(15000);
	motor[chassisR] = 0;
	motor[chassisL] = 0;*/
	//pidStraight(true,false,false,1800);

	/*autoArmUp(1);
	flashLED(5);
	midArm();
	flashLED(5);
	autoArmDownSpec();*/
	/*autoClosePincher();
	flashLED(3);
	autoOpenPincher();*/
}
